<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>reveal.js</title>
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css" id="theme">
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<img src="resource/logo.png" alt="ysyx logo" style="height: 180px; margin: 0 auto 4rem auto; background: transparent;" class="demo-logo">
					<h2 class="r-fit-text">一生一芯 C 阶段结业答辩</h2>
					<p> 姓名：王靳 </p>
					<p> 学校：哈尔滨工业大学（深圳） </p>
				</section>

				<!-- 自动生成的目录页 -->
				<section id="toc">
					<h2>目录</h2>
					<ul id="toc-list" style="font-size: 0.7em; columns: 1; text-align: left;"></ul>
				</section>

				<section>
					<section>
						<h2>从 hello world 窥探 NEMU+AM 的协同工作</h2>
					</section>
					<section>
						<p>am-tests: make run mainargs=h</p>
						<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
							0x80000000: call [_start@0x8000_0000] <- pc 初始化的位置, 初始化 trm
							0x8000000c: call [_trm_init@0x80001ac4] <- 初始化 trm, 并跳转到 main
							0x80001adc:   call [main@0x80000010]
							0x800001d8:     call [printf@0x80003f04] <- 调用 klib 中的 printf
							0x80003f54:       call [vprintf@0x80005408]
							0x8000543c:         call [__vprintf@0x80004a44]
							0x80004ab4:           call [vprintf_helper@0x80005458]
							0x80005498:             call [putch@0x80001a60]
							0x80001a84:               call [outb@0x80001a24] <- mmio, 串口输出
						</code></pre>
						<p>Hello, AM World @ riscv32</p>
					</section>
					<section>
						<p>NEMU初始化PC=0x8000_0000, 这个时候开始运行 _start 处的代码</p>
						<p>那为什么0x8000_0000处就是_start呢?</p>
						<p>这需要两方面的努力: 链接器、装载器</p>
					</section>
					<section>
						<P>这里的装载器可以理解为一个nvm的ram(物理地址)</P>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/isa/riscv32/init.c
							void init_isa() {
								memcpy(guest_to_host(RESET_VECTOR), img, sizeof(img)); /* init ram */
								restart(); /* reset pc */
							}
						</code></pre>
					</section>
					<section>
						<P>链接器需要确定程序的逻辑地址</P>
						<pre data-id="code-animation"><code class="hljs ld" data-trim data-line-numbers>
							ENTRY(_start) /* (1) set _start as entry */
							PHDRS { text PT_LOAD; }
							SECTIONS {
								/* 其中 _pmem_start, _entry_offset 是给链接器传的参数 */
								. = _pmem_start + _entry_offset;
								.text : {
									*(entry) /* (2) put entry */
									*(.text*)
								} : text
								etext = .; _etext = .;
							}
						</code></pre>
					</section>
					<section>
						<p>NEMU复位后, PC指向0x8000_0000, 开始执行 _start 处的代码</p>
						<pre data-id="code-animation"><code class="hljs asm" data-trim data-line-numbers>
							_start:
								mv s0, zero
								la sp, _stack_pointer
								call _trm_init
						</code></pre>
						<p>调用 _trm_init, 然后 _trm_init 又调用 main</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							extern int main(const char *args);
							void _trm_init() {
								int ret = main(mainargs);
								halt(ret);
							}
						</code></pre>
						<p>其中 main 是一个外部函数, 也就是 am-kernels 中定义的五彩缤纷的应用程序</p>
					</section>
				</section>

				<section>
					<section>
						<h2>从 hello world 窥探 Makefile 的层层展开</h2>
					</section>
					<section>
						<p>当我们键入下面这条命令时, 发生了什么?</p>
						<pre data-id="code-animation"><code class="hljs shell" data-trim data-line-numbers>
							kernels/demo> make ARCH=riscv32-nemu run mainargs=h
						</code></pre>
						<pre data-id="code-animation"><code class="hljs Makefile" data-trim data-line-numbers>
							am-kernels/kernels/demo/Makefile
								abstract-machine/Makefile
									DEPENDENCIES.d
									abstract-machine/scripts/riscv32-nemu.mk
										abstract-machine/scripts/isa/riscv.mk
										abstract-machine/scripts/platform/nemu.mk
											abstract-machine/scripts/platform/sim.mk # 抽取了仿真平台通用的结构
											LIB_TEMPLATE:
												abstract-machine/klib/Makefile
												abstract-machine/am/Makefile
											run: nemu/Makefile
												FILELIST_MK
												nemu/include/config/auto.conf
												nemu/include/config/auto.conf.cmd
												nemu/scripts/native.mk
												nemu/scripts/config.mk
													nemu/scripts/build.mk
														DEPENDENCIES.d
													nemu/tools/difftest.mk
													YSYX_ROOT/Makefile # 用于跟踪 git commit

						</code></pre>
					</section>
				</section>
				<section>
					<h2>从 hello world 窥探 printf 的实现 (nemu)</h2>
					<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
						0x800001d8: call [printf@0x80003f04] <- 调用 klib 中的 printf
						0x80003f54:   call [vprintf@0x80005408]
						0x8000543c:     call [__vprintf@0x80004a44]
						0x80004ab4:       call [vprintf_helper@0x80005458]
						0x80005498:         call [putch@0x80001a60]
						0x80001a84:           call [outb@0x80001a24] <- mmio, 串口输出
						[host]:                 decode_exec
						[host]:                   vaddr_write
						[host]:                     paddr_write
						[host]:                       mmio_write
						[host]:                         map_write
						[host]:                           invoke_callback -> serial_io_handler
						[host]:                             serial_putc -> putc
					</code></pre>
				</section>
				<section>
					<h2>从 hello world 窥探 printf 的实现 (npc)</h2>
					<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
						0x800001d8: call [printf@0x80003f04] <- 调用 klib 中的 printf
						0x80003f54:   call [vprintf@0x80005408]
						0x8000543c:     call [__vprintf@0x80004a44]
						0x80004ab4:       call [vprintf_helper@0x80005458]
						0x80005498:         call [putch@0x80001a60]
						0x80001a84:           call [outb@0x80001a24] <- mmio, 串口输出
						[host]:                 [译码]
						[host]:                   [访存]
						[host]:                     [AXI4-Lite总线桥]
						[host]:                       [AXI4LiteUartSlave]
						[host]:                         [printf]
					</code></pre>
				</section>

				<section>
					<h2>单周期硬件框图</h2>
					<img src="resource/single.png" style="width: 70%; height: 70%;">
				</section>
				<section>
					<section>
						<h2>多周期硬件框图</h2>
						<img src="resource/multi.png">
					</section>
					<section>
						<h3>多周期状态机（整体）</h3>
						<img src="resource/core.png">
					</section>
					<section>
						<h3>IFU状态机</h3>
						<img src="resource/ifu.png" style="width: 65%; height: 65%;">
					</section>
					<section>
						<h3>LSU状态机</h3>
						<img src="resource/lsu.png">
					</section>
					<section>
						<h3>AXI4Lite总线Slave状态机</h3>
						<img src="resource/slave.png">
					</section>
				</section>

				<section>
					<section>
						<h2>考核题目：充分理解打字小游戏（键盘输入）</h2>
					</section>
					<section>
						<p>NEMU是如何处理键盘输入的？（状态机视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/cpu/cpu-exec.c
							static void execute(uint64_t n) {
								Decode s;
								for (; n > 0; n--) {
									exec_once(&s, cpu.pc);
									IFDEF(CONFIG_DEVICE, device_update());
								}
							}
						</code></pre>
						<small>有些类似于408考研题中的多周期CPU：取值->间址->执行->中断</small>
					</section>
					<section>
						<p>“中断周期” NEMU 处理键盘输入（状态机视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/device/device.c
							void device_update() {
								SDL_Event event;
								while (SDL_PollEvent(&event)) {
									switch (event.type) {
									case SDL_KEYDOWN: case SDL_KEYUP: {
										uint8_t k = event.key.keysym.scancode;
										bool is_keydown = (event.key.type == SDL_KEYDOWN);
										send_key(k, is_keydown);
										break;
									}
									default: break;
									}
								}
							}
							// nemu/src/device/keyboard.c
							void send_key(uint8_t scancode, bool is_keydown) {
								if (nemu_state.state == NEMU_RUNNING && keymap[scancode] != NEMU_KEY_NONE) {
									uint32_t am_scancode = keymap[scancode] | (is_keydown ? KEYDOWN_MASK : 0);
									key_enqueue(am_scancode);
								}
							}
							static void key_enqueue(uint32_t am_scancode) {
								key_queue[key_r] = am_scancode;
								key_r = (key_r + 1) % KEY_QUEUE_LEN;
							}
						</code></pre>
					</section>
					<section>
						<p>typing-game轮询键盘输入（静态视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// am-kernels/kernels/typing-game/game.c
							int main() {
								while (1) {
									while (1) {
										AM_INPUT_KEYBRD_T ev = ({
											AM_INPUT_KEYBRD_T __io_param;
											ioe_read(AM_INPUT_KEYBRD, &__io_param);
											__io_param;
										  });
										if (ev.keycode == AM_KEY_NONE) { break; } // 循环出口
										if (ev.keydown && ev.keycode == AM_KEY_ESCAPE) halt(0);
										if (ev.keydown && lut[ev.keycode]) { check_hit(lut[ev.keycode]); }
									};
								}
							}
							// abstract-machine/am/src/platform/sim/ioe/ioe.c
							void ioe_read (int reg, void *buf) { ((handler_t)lut[reg])(buf); }
							// abstract-machine/am/src/platform/sim/ioe/input.c
							void __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) {
								uint32_t kc = inl(KBD_ADDR); // mmio
								kbd->keydown = kc & KEYDOWN_MASK ? true : false;
								kbd->keycode = kc & ~KEYDOWN_MASK;
							}
						</code></pre>
					</section>
					<section>
						<p>NEMU处理AM的mmio请求（状态机视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/isa/riscv32/inst.c
							static int decode(Decode * s) {
								...
								INSTPAT("xxx", lw     , I, R(rd) = Mr(src1 + imm, 4));
								...
							}
							// nemu/src/memory/vaddr.c
							word_t vaddr_read(vaddr_t addr, int len) { return paddr_read(addr, len); }
							// nemu/src/memory/paddr.c
							word_t paddr_read(paddr_t addr, int len) {
								if (likely(in_pmem(addr))) { return pmem_read(addr, len); }
								IFDEF(CONFIG_DEVICE, return mmio_read(addr, len));
							}
							// nemu/src/io/mmio.c
							void mmio_write(paddr_t addr, int len, word_t data) {
								IOMap *map = fetch_mmio_map(addr);
								map_write(addr, len, data, map);
							}
							// nemu/src/io/map.c
							void map_write(paddr_t addr, int len, word_t data, IOMap *map) {
								paddr_t offset = addr - map->low;
								host_write(map->space + offset, len, data);
								invoke_callback(map->callback, offset, len, true);
							}
							// nemu/src/device/keyboard.c
							static void i8042_data_io_handler(uint32_t offset, int len, bool is_write) {
								i8042_data_port_base[0] = key_dequeue();
							}
							static uint32_t key_dequeue() {
								uint32_t key = NEMU_KEY_NONE;
								if (key_f != key_r) {
									key = key_queue[key_f];
									key_f = (key_f + 1) % KEY_QUEUE_LEN;
								}
								return key;
							}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>考核题目：充分理解打字小游戏（游戏逻辑）</h2>
					</section>
					<section>
						<p>typing-game主函数（静态视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							int main() {
								ioe_init(); video_init();
								int current = 0, rendered = 0;
								const uint64_t t0 = io_read(AM_TIMER_UPTIME).us;
								while (1) {
									const int frames = (io_read(AM_TIMER_UPTIME).us - t0) / (1000000 / FPS);
									for (; current < frames; current++) { game_logic_update(current); } // ⭐ 时间与游戏逻辑的同步
									while (1) {
										AM_INPUT_KEYBRD_T ev = io_read(AM_INPUT_KEYBRD);
										if (ev.keycode == AM_KEY_NONE) { break; }
										if (ev.keydown && ev.keycode == AM_KEY_ESCAPE) halt(0);
										if (ev.keydown && lut[ev.keycode]) { check_hit(lut[ev.keycode]); }
									}
									if (current > rendered) {
										render(); // 渲染
										rendered = current;
									}
								}
							}
						</code></pre>
						<small>
							游戏的逻辑与时间是高度相关的。但是又因为游戏逻辑的更新与画面更新是串行的。
							但是因为性能问题，会出现“理想游戏逻辑”与“实际游戏逻辑”不同步的情况。
							也就是 ⭐ 这行代码中, 为什么要有 for 循环 （印象深刻的部分）
						</small>
					</section>
					<section>
						<p>game_logic_update（静态视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							void game_logic_update(int frame) {
								if (frame % (FPS / CPS) == 0) { new_char(); }
								for (int i = 0; i < LENGTH(chars); i++) {
									struct character *c = &chars[i];
									if (c->ch) {
										if (c->t > 0) {
											if (--c->t == 0) { // (3)
												c->ch = '\0';
											}
										} else {
											c->y += c->v;
											if (c->y < 0) { c->ch = '\0'; } // (1)
											if (c->y + CHAR_H >= screen_h) { // (2)
												miss++;
												c->v = 0;
												c->y = screen_h - CHAR_H;
												c->t = FPS;
											}
										}
									}
								}
							}
						</code></pre>
						<li>
							<small>
								(1) 在 check_hit 中，按对了会反转c的速度，因此game_logic_update中，y<0意味着按对了。
								并将ch设置为'\0'，表示字符已经消失，所空出的槽位可以立刻给new_char使用
							</small>
						</li>
						<li>
							<small>
								(2) y + CHAR_H >= screen_h 意味着c达到了屏幕的底部，意味着没有来得及按。
								这个时候，并没有直接将ch设置为'\0'，而是延迟FPS帧，直到延迟结束才会进入(3)分支。
								这意味着可以占用chars中的槽位，变相的降低了生成字符的频率。 （印象深刻的部分）
							</small>
						</li>
					</section>
				</section>

				<section>
					<section>
						<h2>考核题目：充分理解打字小游戏（渲染）</h2>
					</section>
					<section>
						<p>render（静态视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							void render() {
								static int x[NCHAR], y[NCHAR], n = 0;
								for (int i = 0; i < n; i++) { io_write(AM_GPU_FBDRAW, x[i], y[i], blank, CHAR_W, CHAR_H, false); }
								n = 0;
								for (int i = 0; i < LENGTH(chars); i++) {
									struct character *c = &chars[i];
									if (c->ch) {
										x[n] = c->x; y[n] = c->y; n++;
										// v > 0: white, 对应的下落, 还没按下
										// v = 0: red, 对应的 miss
										// v < 0: green, 对应的按对的
										int col = (c->v > 0) ? WHITE : (c->v < 0 ? GREEN : RED);
										io_write(AM_GPU_FBDRAW, c->x, c->y, texture[col][c->ch - 'A'], CHAR_W, CHAR_H, false);
									}
								}
								io_write(AM_GPU_FBDRAW, 0, 0, NULL, 0, 0, true);
								for (int i = 0; i < 40; i++) { putch('\b'); }
								printf("Hit: %d; Miss: %d; Wrong: %d", hit, miss, wrong);
							}
						</code> </pre>
					</section>
					<section>
						<p>利用ftrace分析io_write、AM的调用关系（状态机视角）</p>
						<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
							call [render@0x800002d4]
							  call [ioe_write@0x800010f4]
							    call [__am_gpu_fbdraw@0x80001944]
							      call [inl@0x8000177c]
							      ret [inl]
							      call [outl@0x800017ac]
								  ret [outl]
						</code> </pre>
					</section>
					<section>
						<p>类似8086的gpu内存地址映射（静态视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// abstract-machine/klib/include/klib-macros.h
							#define io_write(reg, ...) \
							({ reg##_T __io_param = (reg##_T) { __VA_ARGS__ }; \
							  ioe_write(reg, &__io_param); })
							
							// abstract-machine/am/src/platform/sim/ioe/gpu.c
							void __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) {
								int x = ctl->x, y = ctl->y;
								int w = ctl->w, h = ctl->h;
								if (!ctl->sync && (w == 0 || h == 0)) { return; }
								uint32_t *pixels = ctl->pixels;
								if (pixels == NULL && !(w == 0 && h == 0)) { return; }
								uint32_t *fb = (uint32_t *)(uintptr_t)FB_ADDR;
								uint32_t screen_w = inl(VGACTL_ADDR) >> 16;
								volatile uint32_t *dst = fb + screen_w * y + x;
								uint32_t *src = pixels;
								for (size_t i = 0; i < h; i++) {
									for (size_t j = 0; j < w; j++) { dst[j] = src[j]; }
									// 考虑到 screen_w > w 的情况, 需要额外考虑
									dst += screen_w; src += w;
								}
								if (ctl->sync) { outl(SYNC_ADDR, 1); }
							}
						</code> </pre>
					</section>
					<section>
						<p>NEMU处的显示逻辑（状态机视角）</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/cpu/cpu-exec.c
							static void execute(uint64_t n) {
								Decode s;
								for (; n > 0; n--) {
									exec_once(&s, cpu.pc);
									IFDEF(CONFIG_DEVICE, device_update());
								}
							}
							// nemu/src/device/device.c
							void device_update() { IFDEF(CONFIG_HAS_VGA, vga_update_screen()); }
							// nemu/src/device/vga.c
							void vga_update_screen() {
								if (vgactl_port_base[1]) {
									update_screen();
									vgactl_port_base[1] = 0;
								}
							}
						</code> </pre>
					</section>
				</section>

				<section>
					<section>
						<h2>最复杂的应用：修复 misaligned memory access</h2>
					</section>
					<section>
						<p>我认为最复杂的程序可能还不是 rt-thread-am, 他只是利用了 ecall 和 mret</p>
						<p>我认为最复杂的程序应该是 misaligned memory access</p>
						<p>他涉及到访存异常, 并跳转到异常处理函数, 并把相应的字节搬到正确的内存上</p>
					</section>
					<section>
						<p>硬件方面, 访存异常处理相关的状态机</p>
						<img src="resource/misalign_state.png">
					</section>
					<section>
						<p>访存异常修复流程</p>
						<img src="resource/misalign_flow.png">
					</section>
					<section>
						<p>访存异常修复伪代码</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							int main() { cte_init(handler); unaligned_access(); }
							Context* __am_irq_handle(Context *c) {
								switch(mcause) {
									case 4: handle_unaligned_load(c); break;
								}
							}
							static void handle_unaligned_load(Context *c) {
								addr = mtval;
								[funct3, rd] = decode(mem[mepc]);
								switch (funct3) {
									case 2: // LW - load word
										value = *(uint8_t *)addr |
												(*(uint8_t *)(addr + 1) << 8) |
												(*(uint8_t *)(addr + 2) << 16) |
												(*(uint8_t *)(addr + 3) << 24);
										break;
								}
								gpr[rd] = value;
								mepc += 4;
							}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>一些亮点与debug经历</h2>
					</section>
					<section>
						<p>构建NPC时, 通过Copy-Paste, 复制了nemu的代码, 并将里面解释执行的部分, 替换成了verilator仿真执行的部分</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// npc/src/cpu/cpu-exec.c
							static void execute(uint64_t n) {
								for (; n > 0; n--) {
									if (!exec_once(&s)) {
										set_npc_state(NPC_ABORT, cpu.pc, -1);
										break;
									}
								}
							}
							static bool exec_once(Decode *s) {
								return npc_core_step(s);
							}
							// npc/src/cpu/core.cc
							extern "C" bool npc_core_step(Decode *s) {
								top->io_step = 1;
								const int MAX_CYCLES = 1000; int cycles = 0;
								do {
									tick();
									cycles++;
									if (cycles >= MAX_CYCLES) {
										return false;
									}
								} while (!top->io_debug_valid);
								read_debug_to_decode(s); cpu.pc = s->dnpc;
								sync_gpr_to_cpu(); sync_csr_to_cpu();
								top->io_step = 0; top->eval();
								return true;
							}
						</code></pre>
					</section>
					<section>
						<h2>印象深刻的BUG</h2>
						<li><a href="https://github.com/KINGFIOX/ysyx-workbench/blob/master/npc/BUG_REPORT_DECERR.md" target="_blank">一个由总线桥的默认行为隐藏的 BUG</a></li>
						<li><a href="https://github.com/KINGFIOX/ysyx-workbench/blob/master/npc/BUG_REPORT_DIFFTEST.md" target="_blank">内存初始化与cpu复位顺序 BUG 报告</a></li>
						<li><a href="https://github.com/KINGFIOX/rt-thread-am/blob/master/bsp/abstract-machine/global-variable-bug-analysis.md" target="_blank">全局变量导致的 Bug 分析</a></li>
					</section>
				</section>

			</div>

		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

			// 自动生成目录
			Reveal.on('ready', function() {
				const tocList = document.getElementById('toc-list');
				const sections = document.querySelectorAll('.slides > section');
				let tocIndex = 0;
				
				sections.forEach((section, index) => {
					// 跳过封面和目录页本身
					if (index === 0 || section.id === 'toc') return;
					
					// 查找章节标题 (h2)
					let title = null;
					const h2 = section.querySelector('h2');
					
					// 如果是嵌套的 section（垂直幻灯片），查找第一个子 section 的 h2
					if (!h2) {
						const nestedH2 = section.querySelector('section h2');
						if (nestedH2) title = nestedH2.textContent;
					} else {
						title = h2.textContent;
					}
					
					if (title) {
						tocIndex++;
						const li = document.createElement('li');
						li.style.marginBottom = '0.5em';
						li.style.listStyleType = 'none';
						
						const link = document.createElement('a');
						link.href = '#/' + index;
						link.textContent = tocIndex + '. ' + title;
						link.style.color = '#2a76dd';
						link.style.textDecoration = 'none';
						
						li.appendChild(link);
						tocList.appendChild(li);
					}
				});
			});

		</script>

	</body>
</html>
