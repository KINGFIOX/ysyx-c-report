<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>reveal.js</title>
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css" id="theme">
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<img src="resource/logo.png" alt="ysyx logo" style="height: 180px; margin: 0 auto 4rem auto; background: transparent;" class="demo-logo">
					<h2 class="r-fit-text">一生一芯 C 阶段结业答辩</h2>
					<p> 姓名：王靳 </p>
					<p> 学校：哈尔滨工业大学（深圳） </p>
				</section>

				<section>
					<section>
						<h2>从 hello world 窥探 NEMU+AM 的协同工作</h2>
					</section>
					<section>
						<p>am-tests: make run mainargs=h</p>
						<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
							0x80000000: call [_start@0x8000_0000] <- pc 初始化的位置, 初始化 trm
							0x8000000c: call [_trm_init@0x80001ac4] <- 初始化 trm, 并跳转到 main
							0x80001adc:   call [main@0x80000010]
							0x800001d8:     call [printf@0x80003f04] <- 调用 klib 中的 printf
							0x80003f54:       call [vprintf@0x80005408]
							0x8000543c:         call [__vprintf@0x80004a44]
							0x80004ab4:           call [vprintf_helper@0x80005458]
							0x80005498:             call [putch@0x80001a60]
							0x80001a84:               call [outb@0x80001a24] <- mmio, 串口输出
						</code></pre>
						<p>Hello, AM World @ riscv32</p>
					</section>
					<section>
						<p>NEMU初始化PC=0x8000_0000, 这个时候开始运行 _start 处的代码</p>
						<p>那为什么0x8000_0000处就是_start呢?</p>
						<p>这需要两方面的努力: 链接器、装载器</p>
					</section>
					<section>
						<P>这里的装载器可以理解为一个nvm的ram(物理地址)</P>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/isa/riscv32/init.c
							void init_isa() {
								memcpy(guest_to_host(RESET_VECTOR), img, sizeof(img)); /* init ram */
								restart(); /* reset pc */
							}
						</code></pre>
					</section>
					<section>
						<P>链接器需要确定程序的逻辑地址</P>
						<pre data-id="code-animation"><code class="hljs ld" data-trim data-line-numbers>
							ENTRY(_start) /* (1) set _start as entry */
							PHDRS { text PT_LOAD; }
							SECTIONS {
								/* 其中 _pmem_start, _entry_offset 是给链接器传的参数 */
								. = _pmem_start + _entry_offset;
								.text : {
									*(entry) /* (2) put entry */
									*(.text*)
								} : text
								etext = .; _etext = .;
							}
						</code></pre>
					</section>
					<section>
						<p>NEMU复位后, PC指向0x8000_0000, 开始执行 _start 处的代码</p>
						<pre data-id="code-animation"><code class="hljs asm" data-trim data-line-numbers>
							_start:
								mv s0, zero
								la sp, _stack_pointer
								call _trm_init
						</code></pre>
						<p>调用 _trm_init, 然后 _trm_init 又调用 main</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							extern int main(const char *args);
							void _trm_init() {
								int ret = main(mainargs);
								halt(ret);
							}
						</code></pre>
						<p>其中 main 是一个外部函数, 也就是 am-kernels 中定义的五彩缤纷的应用程序</p>
					</section>
				</section>

				<section>
					<section>
						<h2>从 hello world 窥探 Makefile 的层层展开</h2>
					</section>
					<section>
						<p>当我们键入下面这条命令时, 发生了什么?</p>
						<pre data-id="code-animation"><code class="hljs shell" data-trim data-line-numbers>
							kernels/demo> make ARCH=riscv32-nemu run mainargs=h
						</code></pre>
						<pre data-id="code-animation"><code class="hljs Makefile" data-trim data-line-numbers>
							am-kernels/kernels/demo/Makefile
								abstract-machine/Makefile
									DEPENDENCIES.d
									abstract-machine/scripts/riscv32-nemu.mk
										abstract-machine/scripts/isa/riscv.mk
										abstract-machine/scripts/platform/nemu.mk
											abstract-machine/scripts/platform/sim.mk # 抽取了仿真平台通用的结构
											LIB_TEMPLATE:
												abstract-machine/klib/Makefile
												abstract-machine/am/Makefile
											run: nemu/Makefile
												FILELIST_MK
												nemu/include/config/auto.conf
												nemu/include/config/auto.conf.cmd
												nemu/scripts/native.mk
												nemu/scripts/config.mk
													nemu/scripts/build.mk
														DEPENDENCIES.d
													nemu/tools/difftest.mk
													YSYX_ROOT/Makefile # 用于跟踪 git commit

						</code></pre>
					</section>
				</section>
				<section>
					<h2>从 hello world 窥探 printf 的实现 (nemu)</h2>
					<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
						0x800001d8: call [printf@0x80003f04] <- 调用 klib 中的 printf
						0x80003f54:   call [vprintf@0x80005408]
						0x8000543c:     call [__vprintf@0x80004a44]
						0x80004ab4:       call [vprintf_helper@0x80005458]
						0x80005498:         call [putch@0x80001a60]
						0x80001a84:           call [outb@0x80001a24] <- mmio, 串口输出
						[host]:                 decode_exec
						[host]:                   vaddr_write
						[host]:                     paddr_write
						[host]:                       mmio_write
						[host]:                         map_write
						[host]:                           invoke_callback -> serial_io_handler
						[host]:                             serial_putc -> putc
					</code></pre>
				</section>
				<section>
					<h2>从 hello world 窥探 printf 的实现 (npc)</h2>
					<pre data-id="code-animation"><code class="hljs txt" data-trim data-line-numbers>
						0x800001d8: call [printf@0x80003f04] <- 调用 klib 中的 printf
						0x80003f54:   call [vprintf@0x80005408]
						0x8000543c:     call [__vprintf@0x80004a44]
						0x80004ab4:       call [vprintf_helper@0x80005458]
						0x80005498:         call [putch@0x80001a60]
						0x80001a84:           call [outb@0x80001a24] <- mmio, 串口输出
						[host]:                 [译码]
						[host]:                   [访存]
						[host]:                     [AXI4-Lite总线桥]
						[host]:                       [AXI4LiteUartSlave]
						[host]:                         [printf]
					</code></pre>
				</section>

				<section>
					<h2>单周期硬件框图</h2>
					<img src="resource/single.png" style="width: 70%; height: 70%;">
				</section>
				<section>
					<section>
						<h2>多周期硬件框图</h2>
						<img src="resource/multi.png">
					</section>
					<section>
						<h3>多周期状态机（整体）</h3>
						<img src="resource/core.png">
					</section>
					<section>
						<h3>IFU状态机</h3>
						<img src="resource/ifu.png" style="width: 65%; height: 65%;">
					</section>
					<section>
						<h3>LSU状态机</h3>
						<img src="resource/lsu.png">
					</section>
					<section>
						<h3>AXI4Lite总线Slave状态机</h3>
						<img src="resource/slave.png">
					</section>
				</section>

				<section>
					<section>
						<h2>考核题目：充分理解打字小游戏（键盘输入）</h2>
					</section>
					<section>
						<p>NEMU是如何处理键盘输入的？</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/cpu/cpu-exec.c
							static void execute(uint64_t n) {
								Decode s;
								for (; n > 0; n--) {
									exec_once(&s, cpu.pc);
									IFDEF(CONFIG_DEVICE, device_update());
								}
							}
						</code></pre>
						<small>有些类似于408考研题中的多周期CPU：取值->间址->执行->中断</small>
					</section>
					<section>
						<p>“中断周期” NEMU 处理键盘输入</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/src/device/device.c
							void device_update() {
								SDL_Event event;
								while (SDL_PollEvent(&event)) {
									switch (event.type) {
									case SDL_KEYDOWN: case SDL_KEYUP: {
										uint8_t k = event.key.keysym.scancode;
										bool is_keydown = (event.key.type == SDL_KEYDOWN);
										send_key(k, is_keydown);
										break;
									}
									default: break;
									}
								}
							}
							// nemu/src/device/keyboard.c
							void send_key(uint8_t scancode, bool is_keydown) {
								if (nemu_state.state == NEMU_RUNNING && keymap[scancode] != NEMU_KEY_NONE) {
									uint32_t am_scancode = keymap[scancode] | (is_keydown ? KEYDOWN_MASK : 0);
									key_enqueue(am_scancode);
								}
							}
							static void key_enqueue(uint32_t am_scancode) {
								key_queue[key_r] = am_scancode;
								key_r = (key_r + 1) % KEY_QUEUE_LEN;
							}
						</code></pre>
					</section>
					<section>
						<p>typing-game轮询键盘输入</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// am-kernels/kernels/typing-game/game.c
							int main() {
								while (1) {
									while (1) {
										AM_INPUT_KEYBRD_T ev = ({
											AM_INPUT_KEYBRD_T __io_param;
											ioe_read(AM_INPUT_KEYBRD, &__io_param);
											__io_param;
										  });
										if (ev.keycode == AM_KEY_NONE) { break; } // 循环出口
										if (ev.keydown && ev.keycode == AM_KEY_ESCAPE) halt(0);
										if (ev.keydown && lut[ev.keycode]) { check_hit(lut[ev.keycode]); }
									};
								}
							}
							// abstract-machine/am/src/platform/sim/ioe/ioe.c
							void ioe_read (int reg, void *buf) { ((handler_t)lut[reg])(buf); }
							// abstract-machine/am/src/platform/sim/ioe/input.c
							void __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) {
								uint32_t kc = inl(KBD_ADDR); // mmio
								kbd->keydown = kc & KEYDOWN_MASK ? true : false;
								kbd->keycode = kc & ~KEYDOWN_MASK;
							}
						</code></pre>
					</section>
					<section>
						<p>NEMU处理AM的mmio请求</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// nemu/isa/riscv32/inst.c
							static int decode(Decode * s) {
								...
								INSTPAT("xxx", lw     , I, R(rd) = Mr(src1 + imm, 4));
								...
							}
							// nemu/src/memory/vaddr.c
							word_t vaddr_read(vaddr_t addr, int len) { return paddr_read(addr, len); }
							// nemu/src/memory/paddr.c
							word_t paddr_read(paddr_t addr, int len) {
								if (likely(in_pmem(addr))) { return pmem_read(addr, len); }
								IFDEF(CONFIG_DEVICE, return mmio_read(addr, len));
							}
							// nemu/src/io/mmio.c
							void mmio_write(paddr_t addr, int len, word_t data) {
								IOMap *map = fetch_mmio_map(addr);
								map_write(addr, len, data, map);
							}
							// nemu/src/io/map.c
							void map_write(paddr_t addr, int len, word_t data, IOMap *map) {
								paddr_t offset = addr - map->low;
								host_write(map->space + offset, len, data);
								invoke_callback(map->callback, offset, len, true);
							}
							// nemu/src/device/keyboard.c
							static void i8042_data_io_handler(uint32_t offset, int len, bool is_write) {
								i8042_data_port_base[0] = key_dequeue();
							}
							static uint32_t key_dequeue() {
								uint32_t key = NEMU_KEY_NONE;
								if (key_f != key_r) {
									key = key_queue[key_f];
									key_f = (key_f + 1) % KEY_QUEUE_LEN;
								}
								return key;
							}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>考核题目：充分理解打字小游戏（游戏逻辑）</h2>
					</section>
					<section>
						<p>typing-game主函数</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							int main() {
								ioe_init(); video_init();
								int current = 0, rendered = 0;
								const uint64_t t0 = io_read(AM_TIMER_UPTIME).us;
								while (1) {
									const int frames = (io_read(AM_TIMER_UPTIME).us - t0) / (1000000 / FPS);
									for (; current < frames; current++) { game_logic_update(current); } // ⭐ 时间与游戏逻辑的同步
									while (1) {
										AM_INPUT_KEYBRD_T ev = io_read(AM_INPUT_KEYBRD);
										if (ev.keycode == AM_KEY_NONE) { break; }
										if (ev.keydown && ev.keycode == AM_KEY_ESCAPE) halt(0);
										if (ev.keydown && lut[ev.keycode]) { check_hit(lut[ev.keycode]); }
									}
									if (current > rendered) {
										render(); // 渲染
										rendered = current;
									}
								}
							}
						</code></pre>
						<small>
							游戏的逻辑与时间是高度相关的。但是又因为游戏逻辑的更新与画面更新是串行的。
							但是因为性能问题，会出现“理想游戏逻辑”与“实际游戏逻辑”不同步的情况。
							也就是 ⭐ 这行代码中, 为什么要有 for 循环 （印象深刻的部分）
						</small>
					</section>
					<section>
					</section>
				</section>

				<section>
					<section>
						<h2>最复杂的应用：修复 misaligned memory access</h2>
					</section>
					<section>
						<p>我认为最复杂的程序可能还不是 rt-thread-am, 他只是利用了 ecall 和 mret</p>
						<p>我认为最复杂的程序应该是 misaligned memory access</p>
						<p>他涉及到访存异常, 并跳转到异常处理函数, 并把相应的字节搬到正确的内存上</p>
					</section>
					<section>
						<p>硬件方面, 访存异常处理相关的状态机</p>
						<img src="resource/misalign_state.png">
					</section>
					<section>
						<p>访存异常修复流程</p>
						<img src="resource/misalign_flow.png">
					</section>
					<section>
						<p>访存异常修复伪代码</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							int main() { cte_init(handler); unaligned_access(); }
							Context* __am_irq_handle(Context *c) {
								switch(mcause) {
									case 4: handle_unaligned_load(c); break;
								}
							}
							static void handle_unaligned_load(Context *c) {
								addr = mtval;
								[funct3, rd] = decode(mem[mepc]);
								switch (funct3) {
									case 2: // LW - load word
										value = *(uint8_t *)addr |
												(*(uint8_t *)(addr + 1) << 8) |
												(*(uint8_t *)(addr + 2) << 16) |
												(*(uint8_t *)(addr + 3) << 24);
										break;
								}
								gpr[rd] = value;
								mepc += 4;
							}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>一些亮点与debug经历</h2>
					</section>
					<section>
						<p>构建NPC时, 通过Copy-Paste, 复制了nemu的代码, 并将里面解释执行的部分, 替换成了verilator仿真执行的部分</p>
						<pre data-id="code-animation"><code class="hljs c" data-trim data-line-numbers>
							// npc/src/cpu/cpu-exec.c
							static void execute(uint64_t n) {
								for (; n > 0; n--) {
									if (!exec_once(&s)) {
										set_npc_state(NPC_ABORT, cpu.pc, -1);
										break;
									}
								}
							}
							static bool exec_once(Decode *s) {
								return npc_core_step(s);
							}
							// npc/src/cpu/core.cc
							extern "C" bool npc_core_step(Decode *s) {
								top->io_step = 1;
								const int MAX_CYCLES = 1000; int cycles = 0;
								do {
									tick();
									cycles++;
									if (cycles >= MAX_CYCLES) {
										return false;
									}
								} while (!top->io_debug_valid);
								read_debug_to_decode(s); cpu.pc = s->dnpc;
								sync_gpr_to_cpu(); sync_csr_to_cpu();
								top->io_step = 0; top->eval();
								return true;
							}
						</code></pre>
					</section>
					<section>
						<h2>印象深刻的BUG</h2>
						<li><a href="https://github.com/KINGFIOX/ysyx-workbench/blob/master/npc/BUG_REPORT_DECERR.md" target="_blank">一个由总线桥的默认行为隐藏的 BUG</a></li>
						<li><a href="https://github.com/KINGFIOX/ysyx-workbench/blob/master/npc/BUG_REPORT_DIFFTEST.md" target="_blank">内存初始化与cpu复位顺序 BUG 报告</a></li>
						<li><a href="https://github.com/KINGFIOX/rt-thread-am/blob/master/bsp/abstract-machine/global-variable-bug-analysis.md" target="_blank">全局变量导致的 Bug 分析</a></li>
					</section>
				</section>

			</div>

		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
